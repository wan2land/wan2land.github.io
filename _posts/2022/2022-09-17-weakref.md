---
layout: post
title: "캐싱, WeakRef 응용하기"
summary: "ES2021에 추가된 WeakRef를 이용, WeakRef는 참조된 객체가 가비지 콜렉터의 대상이 될 때 내부에 포함된 객체가 사라져버립니다. 이를 캐시에 응용해봅시다."
date: 2022-09-17 02:14:15 +09:00
tags: ["weakref", "javascript"]
thumbnail: "/images/2022/2022-09-17-weakref/thumbnail.png"
---

일시적으로 데이터를 담아 둘 때, Map을 활용합니다. 아이디를 통해 사용자를 가져오는 로직이 있다고 해봅시다.

```typescript
class UserFinder {

  findById(id: string) {
    return await this.db.findUserById(id)
  }
}
```

매번 데이터베이스에서 사용자를 가져오기에 서버에 부하가 많아지기 때문에 한번 가져온 사용자를 캐시에 담아두기로 하였습니다. 간단히 구현해보면 다음과 같은 방식이 됩니다.

```typescript
class UserFinder {
  #cachedUsers = new Map()
  
  findById(id: string) {
    if (!this.#cachedUsers.has(id)) {
      const user = await this.db.findUserById(id)
      this.#cachedUsers.set(id, user)
    }
    return this.#cachedUsers.get(id)
  }
}
```

이렇게 만들어서 사용하게 되면 데이터베이스 부하가 적어지게 되겠죠. 그러고 보니 사용하는 쪽에서는 같은 아이디에 대해 같은 객체를 반환하기 때문에 비교 연산자를 통해 같은 객체임을 비교할 수 있겠네요.
(실제 환경에서는 이렇게 사용하는 일은 극히 드뭅니다. 자바스크립트 쪽 ORM에서는 이렇게 제공해주는 경우가 드뭅니다.)

```typescript
class MyController {

  finder: UserFinder

  doSomething() {
    const user1 = finder.getById(30)
    const user2 = finder.getById(30)
    
    user1 === user2 // true
  }
}

```

물론.. 위와 같은 프로그램을 만들어서 서비스를 운영하면, 어느순간 메모리가 모자라서 프로그램이 강제종료 되어버립니다.

```
FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory
```

일반적으로, 객체의 캐싱 생애 주기를 시간으로 잡는데.. 이 글에서는 가비지 콜렉션(Garbage Collection) 될 때 캐시를 삭제하려고 합니다. 가장 먼저 떠오르는건 `WeakMap`이 떠오릅니다. 하지만, `WeakMap`은 키 값을 객체로 갖고 해당 키 값이 가비지 콜렉터의 대상이 될 때 키값에 해당하는 값이 삭제되는 방식입니다.

[The Modern JavaScript Tutorial - WeakMap을 사용한 캐싱의 예시](https://ko.javascript.info/weakmap-weakset#ref-2329)

ES2021에 추가된 `WeakRef`를 이용해봅시다. :-)

```typescript
class UserFinder {
  #cachedUsers = new Map()
  
  findById(id: string) {
    if (!this.#cachedUsers.has(id)) {
      const user = await this.db.findUserById(id)
      this.#cachedUsers.set(id, new WeakRef(user))
    }
    return this.#cachedUsers.get(id).deref()
  }
}
```

`WeakRef`는 참조된 객체가 가비지 콜렉터의 대상이 될 때 내부에 포함된 객체가 사라져버립니다. `deref()` 호출 시 가비지 콜렉션 전이라면 값이 정상적으로 불러와지지만, 객체가 회수된 이후에는 `undefined` 값을 반환합니다.

객체는 정상적으로 회수가 되겠지만, `Map`내부에는 참조를 잃어버린 `WeakRef`가 잔뜩 쌓이게 됩니다. 참조를 잃어버릴 때, `Map`에서 `WeakRef` 객체도 삭제해줘야 합니다. `FinalizationRegistry`를 사용하면 됩니다. `FinalizationRegistry`는 등록된 객체가 가비지 컬레션의 대상이 될 때 함께 등록된 값을 이벤트로 불러줍니다.

```typescript
class UserFinder {
  #cachedUsers = new Map()
  #registry
  
  constructor() {
    this.#registry = new FinalizationRegistry((id) => {
      this.#cachedUsers.delete(id)
    })
  }
  
  findById(id: string) {
    if (!this.#cachedUsers.has(id)) {
      const user = await this.db.findUserById(id)
      this.#cachedUsers.set(id, new WeakRef(user))
      this.#registry.register(user, id)
    }
    return this.#cachedUsers.get(id).deref()
  }
}
```

매번 위와 같이 구현하는게 귀찮다면 다음과 같이 `InvertedWeakMap` 클래스를 만들어두고 사용하는 방법도 있습니다.

```typescript
class InvertedWeakMap<K extends string | symbol, V extends object> {
  _map = new Map<K, WeakRef<V>>()
  _registry: FinalizationRegistry<K>

  constructor() {
    this._registry = new FinalizationRegistry<K>((key) => {
      this._map.delete(key)
    })
  }

  set(key: K, value: V) {
    this._map.set(key, new WeakRef(value))
    this._registry.register(value, key)
  }

  get(key: K): V | undefined {
    const ref = this._map.get(key)
    if (ref) {
      return ref.deref()
    }
  }

  has(key: K): boolean {
    return this._map.has(key) && this.get(key) !== undefined
  }
}
```

## 참고

- [MDN Web Docs - WeakRef](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef)
- [MDN Web Docs - FinalizationRegistry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry)
- [TC39 - WeakRefs TC39 proposal](https://github.com/tc39/proposal-weakrefs)
